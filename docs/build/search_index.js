var documenterSearchIndex = {"docs":
[{"location":"#Enlsip-Documentation","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"","category":"section"},{"location":"#Functions","page":"Enlsip Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"Modules = [Enlsip]\nOrder   = [:function]","category":"page"},{"location":"#Enlsip.enlsip","page":"Enlsip Documentation","title":"Enlsip.enlsip","text":"enlsip(x0, r, c, n, m, q, l, scaling = false, weight_code = 2, MAX_ITER = 100)\n\nMain function for ENLSIP solver. \n\nMust be called with the following arguments: \n\nx0::Vector{Foat64} is the departure point\nr is a function of type ResidualsEval to evaluate residuals values and jacobian\nc is a function of type ConstraintsEval to evaluate constraints values and jacobian\nn::Int64 is the number of parameters\nm::Int64 is the number of residuals \nq::Int64 is the number of equality constraints \nl::Int64 is the total number of constraints (equalities and inequalities)\n\nThe following arguments are optionnal and have default values:\n\nscaling::Bool\nboolean indicating if internal scaling of constraints value and jacobian must be done or not\nfalse by default\nweight_code::Int64 is an int representing the method used to compute penality weights at each iteration\n1 represents maximum norm method\n2 (default value) represents euclidean norm method\nMAX_ITER::Int64\nint defining the maximum number of iterations\nequals 100 by default\nname_output::String\nstring indicating the prefix of the .txt file produced at the end of the algorithm that contains informations about each iteration and termination of the algorithm\ndefault name given is \"output\"\n\n\n\n\n\n","category":"function"},{"location":"#Evaluation-functions-structures","page":"Enlsip Documentation","title":"Evaluation functions structures","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"Modules = [Enlsip]\nOrder   = [:type]\nFilter = t -> typeof(t) === DataType && t <: Enlsip.EvalFunc","category":"page"},{"location":"#Enlsip.ConstraintsEval","page":"Enlsip Documentation","title":"Enlsip.ConstraintsEval","text":"ConstraintsEval <: EvalFunc\n\nSubtype of EvalFunc dedicated to the evalutation of constraints values and jacobian matrix.\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.EvalFunc","page":"Enlsip Documentation","title":"Enlsip.EvalFunc","text":"EvalFunc(ctrl::Int64)\n\nThis structure is used to define functions evaluating residuals, constraints and corresponding jacobians.\n\nBoth functions for residuals and constraints must be written as follows and must not return any value (components are modified in the body of the function):\n\nExample definition of an EvalFunc type function\n\nfunction (h::EvalFunc)(x::Vector{Float64}, hx::Vector{Float64}, Jh::Matrix{Float64})\n    if h.ctrl == 1 \n        hx[:] = [...]\n    elseif h.ctrl == 2\n        Jh[:] = [...] # if supplied anatically\n    end\n    # The elseif block above could also be, if jacobian not supplied anatically\n    # elseif h.ctrl == 2 h.ctrl = 0 end\n    return\nend\n\nThe ctrl field indicates what is computed (i.e. evalutation or jacobian) when calling a function of type EvalFunction.\n\nctrl = 1 means the function h is evaluated at point x, (modifies in place vector hx)\nctrl = 2 means the jacobian of h is computed at point x if jacobian is supplied anatically (then modifies in place matrix Jh)\nif jacobian is not supplied anatically, ctrl is set to 0 on return and jacobian is computed numerically.\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.ResidualsEval","page":"Enlsip Documentation","title":"Enlsip.ResidualsEval","text":"ResidualsEval <: EvalFunc\n\nSubtype of EvalFunc  dedicated to the evalutation of residuals values and jacobian matrix.\n\n\n\n\n\n","category":"type"}]
}
