var documenterSearchIndex = {"docs":
[{"location":"#Enlsip-Documentation","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"","category":"section"},{"location":"#Notations","page":"Enlsip Documentation","title":"Notations","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"The transpose of a given matrix M is written M'.","category":"page"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"It corresponds to Adjoint operation in Julia, equivalent to transposition when using matrices with floats. ","category":"page"},{"location":"#Structures","page":"Enlsip Documentation","title":"Structures","text":"","category":"section"},{"location":"#Structures-to-contain-informations","page":"Enlsip Documentation","title":"Structures to contain informations","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"Modules = [Enlsip]\r\nOrder   = [:type]\r\nFilter = t -> typeof(t) === DataType && !(t <: Enlsip.EvalFunc)","category":"page"},{"location":"#Enlsip.Constraint","page":"Enlsip Documentation","title":"Enlsip.Constraint","text":"Constraint\n\nStruct used to represent the active constraints\n\nFields are the useful informations about active constraints at a point x :\n\ncx : Vector of size t, contains values of constraints in current working set\nA : Matrix of size t x t, jacobian matrix of constraints in current working set\nscaling : Boolean indicating if internal scaling of cx and A is done \ndiag_scale : Vector of size t, contains the diagonal elements of the scaling matrix if internal scaling is done \nThe i-th element equals dfrac1nabla c_i(x) for i = 1t, which is the inverse of the length of A i-th row \nOtherwise, it contains the length of each row in the matrix A\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.Iteration","page":"Enlsip Documentation","title":"Enlsip.Iteration","text":"Iteration\n\nSummarizes the useful informations about an iteration of the algorithm\n\nx : Departure point of the iteration \np : Descent direction\nrx : vector of size m, contains value of residuals at x \ncx : vector of size l, constains value of constraints at x\nt : Number of constraints in current working set (ie constraints considered active)\nα : Value of steplength\nλ : Vector of size t, containts Lagrange multipliers estimates\nrankA : pseudo rank of matrix A, jacobian of active constraints\nrankJ2 : pseudo rank of matrix J2, block extracted from J, jacobian of residuals\nb_gn : right handside of the linear system solved to compute first part of p\nd_gn :  right handside of the linear system solved to compute second part of p\npredicted_reduction : predicted linear progress\nprogress :  reduction in the objective function\nβ : scalar used to estimate convergence factor\nrestart : indicate if current iteration is a restart step or no\nfirst : indicate if current iteration is the first one or no\nadd : indicate if a constraint has been added to the working set \ndel : indicate if a constraint has been deleted from the working set\nindex_del : index of the constraint that has been deleted from working set (0 if no deletion)\ncode : Its value caracterizes the method used to compute the search direction p\n1 represents Gauss-Newton method\n-1 represents Subspace minimization\n2  represents Newton method\nnb_newton_steps : number of search direction computed using the method of Newton\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.WorkingSet","page":"Enlsip Documentation","title":"Enlsip.WorkingSet","text":"WorkingSet\n\nIn ENLSIP, the working-set is a prediction of the set of active constraints at the solution\n\nIt is updated at every iteration thanks to a Lagrangian multipliers estimation\n\nFields of this structure summarize infos about the qualification of the constraints, i.e. :\n\nq : number of equality constraints\nt : number of constraints in current working set (all equalities and some inequalities considered to be active at the solution)\nl : total number of constraints (i.e. equalities and inequalities)\nactive :\nVector of size l\nfirst t elements are indeces of constraints in working set sorted in increasing order, other elements equal 0\ninactive : \nVector of size l-q\nfirst l-t elements are indeces of constraints not in working set sorted in increasing order, other elements equal 0\n\n\n\n\n\n","category":"type"},{"location":"#Evaluation-functions-structures","page":"Enlsip Documentation","title":"Evaluation functions structures","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"Modules = [Enlsip]\r\nOrder   = [:type]\r\nFilter = t -> typeof(t) === DataType && t <: Enlsip.EvalFunc","category":"page"},{"location":"#Enlsip.ConstraintsEval","page":"Enlsip Documentation","title":"Enlsip.ConstraintsEval","text":"ConstraintsEval <: EvalFunc\n\nSubtype of EvalFunc dedicated to the evalutation of constraints values and jacobian matrix.\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.EvalFunc","page":"Enlsip Documentation","title":"Enlsip.EvalFunc","text":"EvalFunc(ctrl::Int64)\n\nThis structure is used to define functions evaluating residuals, constraints and corresponding jacobians.\n\nBoth functions for residuals and constraints must be written as follows and must not return any value (components are modified in the body of the function):\n\nExample definition of an EvalFunc type function\n\nfunction (h::EvalFunc)(x::Vector{Float64}, hx::Vector{Float64}, Jh::Matrix{Float64})\n    if h.ctrl == 1 \n        hx[:] = [...]\n    elseif h.ctrl == 2\n        Jh[:] = [...] # if supplied anatically\n    end\n    # The elseif block above could also be, if jacobian not supplied anatically\n    # elseif h.ctrl == 2 h.ctrl = 0 end\n    return\nend\n\nThe ctrl field indicates what is computed (i.e. evalutation or jacobian) when calling a function of type EvalFunction.\n\nctrl = 1 means the function h is evaluated at point x, (modifies in place vector hx)\nctrl = 2 means the jacobian of h is computed at point x if jacobian is supplied anatically (then modifies in place matrix Jh)\nif jacobian is not supplied anatically, ctrl is set to 0 on return and jacobian is computed numerically.\n\n\n\n\n\n","category":"type"},{"location":"#Enlsip.ResidualsEval","page":"Enlsip Documentation","title":"Enlsip.ResidualsEval","text":"ResidualsEval <: EvalFunc\n\nSubtype of EvalFunc  dedicated to the evalutation of residuals values and jacobian matrix.\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"Enlsip Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"Enlsip Documentation","title":"Enlsip Documentation","text":"Modules = [Enlsip]\r\nOrder   = [:function]","category":"page"},{"location":"#Enlsip.check_termination_criteria-Tuple{Enlsip.Iteration, Enlsip.Iteration, Enlsip.WorkingSet, Enlsip.Constraint, Vector{Float64}, Vector{Float64}, Float64, Vector{Float64}, Int64, Int64, Float64, Float64, Float64, Float64, Int64}","page":"Enlsip Documentation","title":"Enlsip.check_termination_criteria","text":"check_termination_criteria(iter::Iteration,prev_iter::Iteration,W::WorkingSet,active_C::Constraint,x,cx,rx_sum,∇fx,max_iter,nb_iter,ε_abs,ε_rel,ε_x,ε_c,error_code)\n\nEquivalent Fortran77 routine : TERCRI\n\nThis functions checks if any of the termination criteria are satisfied\n\nvarepsilon_cvarepsilon_xvarepsilon_rel and varepsilon_abs are small positive values to test convergence.\n\nThere are convergence criteria (conditions 1 to 7) and abnormal termination criteria (conditions 8 to 12)\n\nc(x_k)  varepsilon_c for constraints in the working set and all inactive constraints must be strictly positive\nA_k^T lambda_k - nabla f(x_k)  sqrtvarepsilon_rel*(1 + nabla f(x_k))\nundersetimin lambda_k^(i) geq varepsilon_rel*undersetimax lambda_k^(i)\nor undersetimin lambda_k^(i)  geq varepsilon_rel*(1+r(x_k)^2) if there is only one inequality\nd_1^2 leq varepsilon_x * x_k\nr(x_k)^2 leq varepsilon_abs^2\nx_k-x_k-1  varepsilon_x * x_k\ndfracsqrtvarepsilon_relp_k   025\nnumber of iterations exceeds MAX_ITER\nConvergence to a non feasible point\nSecond order derivatives not allowed by the user (TODO : not implemented yet)\nNewton step fails or too many Newton steps done\nThe latest direction is not a descent direction to the merit function (TODO : not implemented yet)\n\nConcitions 1 to 3 are necessary conditions.\n\nThis functions returns exit_code, an integer containing infos about the termination of the algorithm\n\n0 if no termination criterion is satisfied\n10000 if criterion 4 satisfied\n2000 if criterion 5 satisfied\n300 if criterion 6 satisfied\n40 if criterion 7 satisfied\n-2 if criterion 8 satisfied\n-5 if criterion 11 satisfied\n-9  if the search direction is computed with Newton method at least five times\n-10 if not possible to satisfy the constraints\n\nIf multiple convergence criteria are satisfied, their corresponding values are added into exit_code.\n\nexit_code != 0 means the termination of the algorithm\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.compute_steplength-Tuple{Enlsip.Iteration, Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Enlsip.WorkingSet, Vector{Vector{Float64}}, Int64, Int64, Int64, Float64, Int64, Int64, Int64, Int64}","page":"Enlsip Documentation","title":"Enlsip.compute_steplength","text":"compute_steplength\n\nEquivalent Fortran77 routine : STPLNG\n\nUpdate the penalty weights and compute the steplength using the merit function psi\n\nIf search direction computed with method of Newton, an undamped step is taken, i.e. alpha =1\n\nOn return\n\nα : the computed steplength\nw : vector of size l, containts the computed penalty constants \n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.enlsip-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Int64, Int64, Int64, Int64}","page":"Enlsip Documentation","title":"Enlsip.enlsip","text":"enlsip(x0,r,c,n,m,q,l;scaling = false,weight_code = 2,MAX_ITER = 100,ε_abs = 1e-10,ε_rel = 1e-3,ε_x = 1e-3,ε_c = 1e-3)\n\nMain function for ENLSIP solver. \n\nMust be called with the following arguments: \n\nx0::Vector{Foat64} is the departure point\nr is a function of type ResidualsEval to evaluate residuals values and jacobian\nc is a function of type ConstraintsEval to evaluate constraints values and jacobian\nn::Int64 is the number of parameters\nm::Int64 is the number of residuals \nq::Int64 is the number of equality constraints \nl::Int64 is the total number of constraints (equalities and inequalities)\n\nThe following arguments are optionnal and have default values:\n\nscaling::Bool\nboolean indicating if internal scaling of constraints value and jacobian must be done or not\nfalse by default\nweight_code::Int64 is an int representing the method used to compute penality weights at each iteration\n1 represents maximum norm method\n2 (default value) represents euclidean norm method\nMAX_ITER::Int64\nint defining the maximum number of iterations\nequals 100 by default\nε_abs, ε_rel, ε_x and ε_c\nsmall positive scalars of type Float64 to test convergence\ndefault are the recommended one by the authors, i.e. \nε_rel = ε_x = ε_c = 1e-3 \nε_abs = 1e-10\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.first_lagrange_mult_estimate!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool, Vector{Float64}, LinearAlgebra.Factorization{Float64}}","page":"Enlsip Documentation","title":"Enlsip.first_lagrange_mult_estimate!","text":"first_lagrange_mult_estimate(A,λ,∇fx,cx,scaling_done,diag_scale,F)\n\nEquivalent Fortran77 routine : MULEST\n\nCompute first order estimate of Lagrange multipliers\n\nSolves the system A' * λ_ls = ∇f(x) using QR factorisation of A' given by :\n\nA'*P1 = Q1 * [R;0]\n\nThen, computes estimates of lagrage multipliers by forming :\n\nλ = λ_ls - inv(A*A') * cx\n\nParameters\n\nA : nxt jacobian matrix of constraints in current working set \ncx : vector of size t, contains evalutations of constraints in current working set\nλ : vector of size t, represent the lagrange multipliers associated to current actives contraints\n∇fx: vector of size n, equals the gradient vector of the objective function\nscaling_done : Boolean indicating if internal scaling of contraints has been done or not\ndiag_scale : Vector of size t, contains the diagonal elements of the scaling matrix if internal scaling is done \nThe i-th element equals dfrac1nabla c_i(x) for i = 1t, which is the inverse of the length of A i-th row \nOtherwise, it contains the length of each row in the matrix A\n\nOn return\n\nModifies in place the vector λ with the first order estimate of Lagrange multipliers.\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.gn_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, Int64, Int64, Float64, Enlsip.Iteration}","page":"Enlsip Documentation","title":"Enlsip.gn_search_direction","text":"gn_search_direction(J,rx,cx,Q1,L11,P1,F_L11,rankA,t,τ,current_iter)\n\nEquivalent Fortran77 routine : GNSRCH\n\nSolves for y one of the compound systems :\n\n    [L11;0] * y = b   \n    J * y = -rx\n\nor \n\n    [R11;0] * y = Q2' * B\n    J * y = -rx\n\nThen, compute the search direction p = Q1 * y\n\nIf rankA = t, the first system is solved, otherwise, the second one is solved. \n\nParameters\n\nJ : mxn jacobian matrix of residuals\nrx : residuals vector of size m\ncx : active constraints vector of size t\nQ1, L11, P1 :  components of the LQ decomposition of active constraints jacobian matrix A*P1 = Q1 * [L11 ; 0]\nQ1 orthogonal nxn orthogonal matrix\nL11 txt lower triangular matrix\nP1 txt permutation matrix\nF_L11 : QRPivoted object containing infos about  QR decomposition of matrix L11 such that  \nL11 * P2 = Q2 * [R11;0]\nrankA : pseudo-rank of matrix A\nτ : small positive value to compute the pseudo-rank of matrices\n\nOn return\n\np_gn : vector of size n, contains the computed search direction \nF_J2 : QR decomposition of Matrix J2 defined in sub_search_direction\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.init_working_set-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Enlsip.Iteration, Int64, Int64}","page":"Enlsip Documentation","title":"Enlsip.init_working_set","text":"init_working_set(cx,K,step,q,l)\n\nEquivalent Fortran77 routine : INIALC\n\nCompute the first working set by cheking which inequality constraints are strictly positive.\n\nThen, initialize the penalty constants.\n\nParameters\n\ncx : vector of size l, contains contraints evaluations\nK : array of vectors, contains infos about penalty constants computed throughout the algorithm\nstep : object of type Iteration, containts infos about the current iteration, i.e. the first one when this function is called\nq : number of equality constraints\nl : total number of constraints\n\nOn return\n\nfirst_working_set : WorkingSet object, contains infos about the first working set\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.new_point!-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Int64, Int64, Int64}","page":"Enlsip Documentation","title":"Enlsip.new_point!","text":"new_point!(x,r,rx,c,cx,J,A,n,m,l)\n\nEquivalent Fortran77 routine : NEWPNT\n\nCompute in place the jacobians J and A corresponding to the residuals rx and the constraints cx evaluations respectively at current point x.\n\nn is the number of parameters (size of x)\nm is the number of residuals (size of rx)\nlis the number of constraints (size of cx)\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.psi-Tuple{Vector{Float64}, Float64, Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Vector{Float64}, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Enlsip Documentation","title":"Enlsip.psi","text":"psi(x,α,p,r,c,w,m,l,t,active,inactive)\n\nCompute and return the evaluation of the merit function at (x+alpha pw) with current working set mathcalW and the set of inactive constraints mathcalI\n\npsi(xw) = dfrac12r(x)^2 +  dfrac12sum_i in mathcalW w_ic_i(x)^2 + dfrac12 sum_j in mathcalI w_jmin(0c_j(x))^2\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.search_direction_analys","page":"Enlsip Documentation","title":"Enlsip.search_direction_analys","text":"search_direction_analys\n\nEquivalent Fortran77 routine : ANALYS\n\nCheck if the latest step was sufficientlt good and eventually recompute the search direction by using either subspace minimization or the method of Newton\n\nOn return\n\nerror_code : integer indicating if there was an error if computations. In current version, errors can come from the method of Newton\n\n\n\n\n\n","category":"function"},{"location":"#Enlsip.sub_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, LinearAlgebra.Factorization, Int64, Int64, Int64, Int64, Int64, Int64}","page":"Enlsip Documentation","title":"Enlsip.sub_search_direction","text":"sub_search_direction(J1,rx,cx,Q1,L11,P1,F_L11,F_J2,n,t,rankA,dimA,dimJ2,code)\n\nEquivalent Fortran77 routine : SUBDIR\n\nCompute a search direction p by solving two triangular systems of equations.\n\nFirst, for p1, either L11*p1 = -P1' * cx or R11*p1 = -Q2' * P1' * cx is solved.\n\nThen for p2, R22*p2 = -Q3^T * [J1*p1 + rx] is solved.\n\n[J1;J2] = J * Q1 * P2 where J is the jacobian matrix of residuals.\n\nFinally, the search direction is computed by forming : p = Q1 * [p1 ; P3*p2]\n\nParameters\n\nrx : residuals vector of size m\ncx : active constraints vector of size t\nQ1, L11, P1 :  components of the LQ decomposition of active constraints jacobian matrix A*P1 = Q1 * [L11 ; 0]\nQ1 orthogonal nxn orthogonal matrix\nL11 txt lower triangular matrix\nP1 txt permutation matrix\nF_L11 : QRPivoted object containing infos about  QR decomposition of matrix L11 such that  \nL11 * P2 = Q2 * [R11;0]\nF_J2 : QRPivoted object containing infos about  QR decomposition of matrix J2, last m-rankA columns of J*Q1\nJ2 * P3 = Q3 * [R22;0]\nJ1 first rankA columns of matrix J*Q1\nn is the number of parameters\nm is the number of residuals (size of rx)\nt is the number of constraint in current working set\nrankA : pseudo-rank of matrix A\ndimA : number of columns of matrix R11 that should be used when R11*p1 = -Q2' * P1' * cx is solved\ndimJ2 : number of columns of matrix R22 that should be used when R22*p2 = -Q3^T * [J1*p1 + rx] is solved\ncode : interger indicating which system to solve to compute p1\n\nOn return\n\np : vector of size n, contains the computed search direction \nb : vector of size t, contains the right handside of the system solved to compute p1\nd : vector of size m, contains the right handside of the system solved to compute p2\n\n\n\n\n\n","category":"method"},{"location":"#Enlsip.update_working_set-Tuple{Enlsip.WorkingSet, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.Iteration}","page":"Enlsip Documentation","title":"Enlsip.update_working_set","text":"Equivalent Fortran77 routine : WRKSET\n\nFirst, an estimate the lagrange multipliers is computed. \n\nIf there are negative values among the multipliers computed, the constraint associated to the most negative multiplier is deleted from the working set.\n\nThen, compute the search direction using Gauss-Newton method.\n\nParameters\n\nW : represents the current working set (see WorkingSet for more details). Fields t, active and inactive may be modified when deleting a constraint\nrx : vector of size m containing residuals evaluations\nA : lxn jacobian matrix of constraints\nJ = mxn jacobian matrixe of residuals\nC : represents constraints in current working set (see Constraint for more details)\n∇fx : vector of size n, gradient vector of the objective function\np_gn : buffer vector of size n, represents the search direction\niter_k : Contains infos about the current iteration (see Iteration)\n\nOn return\n\nP1, L11, Q1, F_L11 and F_J2 : QR decompositions used to solve linear systems when computing the search direction in sub_search_direction\nThe fields of iter_k related to the computation of the search direction are modified in place \n\n\n\n\n\n","category":"method"}]
}
