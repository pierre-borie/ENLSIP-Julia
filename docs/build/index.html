<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Enlsip Documentation · Enlsip.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Enlsip.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Enlsip Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Notations"><span>Notations</span></a></li><li><a class="tocitem" href="#Structures"><span>Structures</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Enlsip Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Enlsip Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Enlsip-Documentation"><a class="docs-heading-anchor" href="#Enlsip-Documentation">Enlsip Documentation</a><a id="Enlsip-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Enlsip-Documentation" title="Permalink"></a></h1><h1 id="Notations"><a class="docs-heading-anchor" href="#Notations">Notations</a><a id="Notations-1"></a><a class="docs-heading-anchor-permalink" href="#Notations" title="Permalink"></a></h1><p>The transpose of a given matrix <code>M</code> is written <code>M&#39;</code>.</p><p>It corresponds to <code>Adjoint</code> operation in Julia, equivalent to transposition when using matrices with floats. </p><h2 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h2><h3 id="Structures-to-contain-informations"><a class="docs-heading-anchor" href="#Structures-to-contain-informations">Structures to contain informations</a><a id="Structures-to-contain-informations-1"></a><a class="docs-heading-anchor-permalink" href="#Structures-to-contain-informations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Enlsip.Constraint" href="#Enlsip.Constraint"><code>Enlsip.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Constraint</code></pre><p>Struct used to represent the active constraints</p><p>Fields are the useful informations about active constraints at a point x :</p><ul><li><p><code>cx</code> : Vector of size t, contains values of constraints in current working set</p></li><li><p><code>A</code> : Matrix of size <code>t</code> x <code>t</code>, jacobian matrix of constraints in current working set</p></li><li><p><code>scaling</code> : Boolean indicating if internal scaling of <code>cx</code> and <code>A</code> is done </p></li><li><p><code>diag_scale</code> : Vector of size <code>t</code>, contains the diagonal elements of the scaling matrix if internal scaling is done </p><ul><li>The i-th element equals <span>$\dfrac{1}{\|\nabla c_i(x)\|}$</span> for <span>$i = 1,...,t$</span>, which is the inverse of the length of <code>A</code> i-th row </li><li>Otherwise, it contains the length of each row in the matrix <code>A</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L88-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.Iteration" href="#Enlsip.Iteration"><code>Enlsip.Iteration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Iteration</code></pre><p>Summarizes the useful informations about an iteration of the algorithm</p><ul><li><p><code>x</code> : Departure point of the iteration </p></li><li><p><code>p</code> : Descent direction</p></li><li><p><code>rx</code> : vector of size <code>m</code>, contains value of residuals at <code>x</code> </p></li><li><p><code>cx</code> : vector of size <code>l</code>, constains value of constraints at <code>x</code></p></li><li><p><code>t</code> : Number of constraints in current working set (ie constraints considered active)</p></li><li><p><code>α</code> : Value of steplength</p></li><li><p><code>λ</code> : Vector of size <code>t</code>, containts Lagrange multipliers estimates</p></li><li><p><code>rankA</code> : pseudo rank of matrix <code>A</code>, jacobian of active constraints</p></li><li><p><code>rankJ2</code> : pseudo rank of matrix <code>J2</code>, block extracted from <code>J</code>, jacobian of residuals</p></li><li><p><code>b_gn</code> : right handside of the linear system solved to compute first part of <code>p</code></p></li><li><p><code>d_gn</code> :  right handside of the linear system solved to compute second part of <code>p</code></p></li><li><p><code>predicted_reduction</code> : predicted linear progress</p></li><li><p><code>progress</code> :  reduction in the objective function</p></li><li><p><code>β</code> : scalar used to estimate convergence factor</p></li><li><p><code>restart</code> : indicate if current iteration is a restart step or no</p></li><li><p><code>first</code> : indicate if current iteration is the first one or no</p></li><li><p><code>add</code> : indicate if a constraint has been added to the working set </p></li><li><p><code>del</code> : indicate if a constraint has been deleted from the working set</p></li><li><p><code>index_del</code> : index of the constraint that has been deleted from working set (<code>0</code> if no deletion)</p></li><li><p><code>code</code> : Its value caracterizes the method used to compute the search direction <code>p</code></p><ul><li><p><code>1</code> represents Gauss-Newton method</p></li><li><p><code>-1</code> represents Subspace minimization</p></li><li><p><code>2</code>  represents Newton method</p></li></ul></li><li><p><code>nb_newton_steps</code> : number of search direction computed using the method of Newton</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L4-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.WorkingSet" href="#Enlsip.WorkingSet"><code>Enlsip.WorkingSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WorkingSet</code></pre><p>In ENLSIP, the working-set is a prediction of the set of active constraints at the solution</p><p>It is updated at every iteration thanks to a Lagrangian multipliers estimation</p><p>Fields of this structure summarize infos about the qualification of the constraints, i.e. :</p><ul><li><p><code>q</code> : number of equality constraints</p></li><li><p><code>t</code> : number of constraints in current working set (all equalities and some inequalities considered to be active at the solution)</p></li><li><p><code>l</code> : total number of constraints (i.e. equalities and inequalities)</p></li><li><p><code>active</code> :</p><ul><li><p><code>Vector</code> of size <code>l</code></p></li><li><p>first <code>t</code> elements are indeces of constraints in working set sorted in increasing order, other elements equal <code>0</code></p></li></ul></li><li><p><code>inactive</code> : </p><ul><li><p><code>Vector</code> of size <code>l-q</code></p></li><li><p>first <code>l-t</code> elements are indeces of constraints not in working set sorted in increasing order, other elements equal <code>0</code></p></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L137-L164">source</a></section></article><h3 id="Evaluation-functions-structures"><a class="docs-heading-anchor" href="#Evaluation-functions-structures">Evaluation functions structures</a><a id="Evaluation-functions-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-functions-structures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Enlsip.ConstraintsEval" href="#Enlsip.ConstraintsEval"><code>Enlsip.ConstraintsEval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstraintsEval &lt;: EvalFunc</code></pre><p>Subtype of <a href="#Enlsip.EvalFunc"><code>EvalFunc</code></a> dedicated to the evalutation of constraints values and jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.EvalFunc" href="#Enlsip.EvalFunc"><code>Enlsip.EvalFunc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvalFunc(ctrl::Int64)</code></pre><p>This structure is used to define functions evaluating residuals, constraints and corresponding jacobians.</p><p>Both functions for residuals and constraints must be written as follows and must not return any value (components are modified in the body of the function):</p><p><strong>Example definition of an EvalFunc type function</strong></p><pre><code class="language-julia hljs">function (h::EvalFunc)(x::Vector{Float64}, hx::Vector{Float64}, Jh::Matrix{Float64})
    if h.ctrl == 1 
        hx[:] = [...]
    elseif h.ctrl == 2
        Jh[:] = [...] # if supplied anatically
    end
    # The elseif block above could also be, if jacobian not supplied anatically
    # elseif h.ctrl == 2 h.ctrl = 0 end
    return
end</code></pre><p>The <code>ctrl</code> field indicates what is computed (i.e. evalutation or jacobian) when calling a function of type <code>EvalFunction</code>.</p><ul><li><p><code>ctrl</code> = <span>$1$</span> means the function <code>h</code> is evaluated at point <code>x</code>, (modifies in place vector <code>hx</code>)</p></li><li><p><code>ctrl</code> = <span>$2$</span> means the jacobian of <code>h</code> is computed at point <code>x</code> if jacobian is supplied anatically (then modifies in place matrix <code>Jh</code>)</p></li><li><p>if jacobian is not supplied anatically, <code>ctrl</code> is set to <span>$0$</span> on return and jacobian is computed numerically.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L194-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.ResidualsEval" href="#Enlsip.ResidualsEval"><code>Enlsip.ResidualsEval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ResidualsEval &lt;: EvalFunc</code></pre><p>Subtype of <a href="#Enlsip.EvalFunc"><code>EvalFunc</code></a>  dedicated to the evalutation of residuals values and jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L226-L230">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Enlsip.check_termination_criteria-Tuple{Enlsip.Iteration, Enlsip.Iteration, Enlsip.WorkingSet, Enlsip.Constraint, Vector{Float64}, Vector{Float64}, Float64, Vector{Float64}, Int64, Int64, Float64, Float64, Float64, Float64, Int64}" href="#Enlsip.check_termination_criteria-Tuple{Enlsip.Iteration, Enlsip.Iteration, Enlsip.WorkingSet, Enlsip.Constraint, Vector{Float64}, Vector{Float64}, Float64, Vector{Float64}, Int64, Int64, Float64, Float64, Float64, Float64, Int64}"><code>Enlsip.check_termination_criteria</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_termination_criteria(iter::Iteration,prev_iter::Iteration,W::WorkingSet,active_C::Constraint,x,cx,rx_sum,∇fx,max_iter,nb_iter,ε_abs,ε_rel,ε_x,ε_c,error_code)</code></pre><p>Equivalent Fortran77 routine : <code>TERCRI</code></p><p>This functions checks if any of the termination criteria are satisfied</p><p><span>$\varepsilon_c,\varepsilon_x,\varepsilon_{rel}$</span> and <span>$\varepsilon_{abs}$</span> are small positive values to test convergence.</p><p>There are convergence criteria (conditions 1 to 7) and abnormal termination criteria (conditions 8 to 12)</p><ol><li><p><span>$\|c(x_k)\| &lt; \varepsilon_c$</span> for constraints in the working set and all inactive constraints must be strictly positive</p></li><li><p><span>$\|A_k^T \lambda_k - \nabla f(x_k)\| &lt; \sqrt{\varepsilon_{rel}}*(1 + \|\nabla f(x_k)\|)$</span></p></li><li><p><span>$\underset{i}{\min}\ \lambda_k^{(i)} \geq \varepsilon_{rel}*\underset{i}{\max}\ |\lambda_k^{(i)}|$</span></p><ul><li>or <span>$\underset{i}{\min}\ \lambda_k^{(i)}  \geq \varepsilon_{rel}*(1+\|r(x_k)\|^2)$</span> if there is only one inequality</li></ul></li><li><p><span>$\|d_1\|^2 \leq \varepsilon_x * \|x_k\|$</span></p></li><li><p><span>$\|r(x_k)\|^2 \leq \varepsilon_{abs}^2$</span></p></li><li><p><span>$\|x_k-x_{k-1}\| &lt; \varepsilon_x * \|x_k\|$</span></p></li><li><p><span>$\dfrac{\sqrt{\varepsilon_{rel}}}{\|p_k\|}  &gt; 0.25$</span></p></li><li><p>number of iterations exceeds <code>MAX_ITER</code></p></li><li><p>Convergence to a non feasible point</p></li><li><p>Second order derivatives not allowed by the user (TODO : not implemented yet)</p></li><li><p>Newton step fails or too many Newton steps done</p></li><li><p>The latest direction is not a descent direction to the merit function (TODO : not implemented yet)</p></li></ol><p>Concitions 1 to 3 are necessary conditions.</p><p>This functions returns <code>exit_code</code>, an integer containing infos about the termination of the algorithm</p><ul><li><p><code>0</code> if no termination criterion is satisfied</p></li><li><p><code>10000</code> if criterion 4 satisfied</p></li><li><p><code>2000</code> if criterion 5 satisfied</p></li><li><p><code>300</code> if criterion 6 satisfied</p></li><li><p><code>40</code> if criterion 7 satisfied</p></li><li><p><code>-2</code> if criterion 8 satisfied</p></li><li><p><code>-5</code> if criterion 11 satisfied</p></li><li><p><code>-9</code>  if the search direction is computed with Newton method at least five times</p></li><li><p><code>-10</code> if not possible to satisfy the constraints</p></li></ul><p>If multiple convergence criteria are satisfied, their corresponding values are added into <code>exit_code</code>.</p><p><code>exit_code != 0</code> means the termination of the algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L2424-L2489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.compute_steplength-Tuple{Enlsip.Iteration, Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Enlsip.WorkingSet, Vector{Vector{Float64}}, Int64, Int64, Int64, Float64, Int64, Int64, Int64, Int64}" href="#Enlsip.compute_steplength-Tuple{Enlsip.Iteration, Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Enlsip.WorkingSet, Vector{Vector{Float64}}, Int64, Int64, Int64, Float64, Int64, Int64, Int64, Int64}"><code>Enlsip.compute_steplength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_steplength</code></pre><p>Equivalent Fortran77 routine : STPLNG</p><p>Update the penalty weights and compute the steplength using the merit function <a href="#Enlsip.psi-Tuple{Vector{Float64}, Float64, Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Vector{Float64}, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>psi</code></a></p><p>If search direction computed with method of Newton, an undamped step is taken, i.e. <span>$\alpha =1$</span></p><p><strong>On return</strong></p><ul><li><p><code>α</code> : the computed steplength</p></li><li><p><code>w</code> : vector of size <code>l</code>, containts the computed penalty constants </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L2323-L2337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.enlsip-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Int64, Int64, Int64, Int64}" href="#Enlsip.enlsip-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Int64, Int64, Int64, Int64}"><code>Enlsip.enlsip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enlsip(x0,r,c,n,m,q,l;scaling = false,weight_code = 2,MAX_ITER = 100,ε_abs = 1e-10,ε_rel = 1e-3,ε_x = 1e-3,ε_c = 1e-3)</code></pre><p>Main function for ENLSIP solver. </p><p>Must be called with the following arguments: </p><ul><li><p><code>x0::Vector{Foat64}</code> is the departure point</p></li><li><p><code>r</code> is a function of type <a href="#Enlsip.ResidualsEval"><code>ResidualsEval</code></a> to evaluate residuals values and jacobian</p></li><li><p><code>c</code> is a function of type <a href="#Enlsip.ConstraintsEval"><code>ConstraintsEval</code></a> to evaluate constraints values and jacobian</p></li><li><p><code>n::Int64</code> is the number of parameters</p></li><li><p><code>m::Int64</code> is the number of residuals </p></li><li><p><code>q::Int64</code> is the number of equality constraints </p></li><li><p><code>l::Int64</code> is the total number of constraints (equalities and inequalities)</p></li></ul><p>The following arguments are optionnal and have default values:</p><ul><li><p><code>scaling::Bool</code></p><ul><li><p>boolean indicating if internal scaling of constraints value and jacobian must be done or not</p></li><li><p><code>false</code> by default</p></li></ul></li><li><p><code>weight_code::Int64</code> is an int representing the method used to compute penality weights at each iteration</p><ul><li><p><code>1</code> represents maximum norm method</p></li><li><p><code>2</code> (default value) represents euclidean norm method</p></li></ul></li><li><p><code>MAX_ITER::Int64</code></p><ul><li><p>int defining the maximum number of iterations</p></li><li><p>equals <code>100</code> by default</p></li></ul></li><li><p><code>ε_abs</code>, <code>ε_rel</code>, <code>ε_x</code> and <code>ε_c</code></p><ul><li><p>small positive scalars of type <code>Float64</code> to test convergence</p></li><li><p>default are the recommended one by the authors, i.e. </p><ul><li><code>ε_rel = ε_x = ε_c = 1e-3</code> </li><li><code>ε_abs = 1e-10</code></li></ul></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L2636-L2685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.first_lagrange_mult_estimate!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool, Vector{Float64}, LinearAlgebra.Factorization{Float64}}" href="#Enlsip.first_lagrange_mult_estimate!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool, Vector{Float64}, LinearAlgebra.Factorization{Float64}}"><code>Enlsip.first_lagrange_mult_estimate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first_lagrange_mult_estimate(A,λ,∇fx,cx,scaling_done,diag_scale,F)</code></pre><p>Equivalent Fortran77 routine : MULEST</p><p>Compute first order estimate of Lagrange multipliers</p><p>Solves the system <code>A&#39; * λ_ls = ∇f(x)</code> using QR factorisation of <code>A&#39;</code> given by :</p><ul><li><code>A&#39;*P1 = Q1 * [R;0]</code></li></ul><p>Then, computes estimates of lagrage multipliers by forming :</p><p><code>λ = λ_ls - inv(A*A&#39;) * cx</code></p><p><strong>Parameters</strong></p><ul><li><p><code>A</code> : <code>n</code>x<code>t</code> jacobian matrix of constraints in current working set </p></li><li><p><code>cx</code> : vector of size <code>t</code>, contains evalutations of constraints in current working set</p></li><li><p><code>λ</code> : vector of size <code>t</code>, represent the lagrange multipliers associated to current actives contraints</p></li><li><p><code>∇fx</code>: vector of size <code>n</code>, equals the gradient vector of the objective function</p></li><li><p><code>scaling_done</code> : Boolean indicating if internal scaling of contraints has been done or not</p></li><li><p><code>diag_scale</code> : Vector of size <code>t</code>, contains the diagonal elements of the scaling matrix if internal scaling is done </p><ul><li>The i-th element equals <span>$\dfrac{1}{\|\nabla c_i(x)\|}$</span> for <span>$i = 1,...,t$</span>, which is the inverse of the length of <code>A</code> i-th row </li><li>Otherwise, it contains the length of each row in the matrix <code>A</code></li></ul></li></ul><p><strong>On return</strong></p><p>Modifies in place the vector <code>λ</code> with the first order estimate of Lagrange multipliers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L675-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.gn_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, Int64, Int64, Float64, Enlsip.Iteration}" href="#Enlsip.gn_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, Int64, Int64, Float64, Enlsip.Iteration}"><code>Enlsip.gn_search_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gn_search_direction(J,rx,cx,Q1,L11,P1,F_L11,rankA,t,τ,current_iter)</code></pre><p>Equivalent Fortran77 routine : GNSRCH</p><p>Solves for <code>y</code> one of the compound systems :</p><pre><code class="nohighlight hljs">    [L11;0] * y = b   
    J * y = -rx</code></pre><p>or </p><pre><code class="nohighlight hljs">    [R11;0] * y = Q2&#39; * B
    J * y = -rx</code></pre><p>Then, compute the search direction <code>p = Q1 * y</code></p><p>If <code>rankA = t</code>, the first system is solved, otherwise, the second one is solved. </p><p><strong>Parameters</strong></p><ul><li><p><code>J</code> : <code>m</code>x<code>n</code> jacobian matrix of residuals</p></li><li><p><code>rx</code> : residuals vector of size <code>m</code></p></li><li><p><code>cx</code> : active constraints vector of size <code>t</code></p></li><li><p><code>Q1</code>, <code>L11</code>, <code>P1</code> :  components of the LQ decomposition of active constraints jacobian matrix <code>A*P1 = Q1 * [L11 ; 0]</code></p><ul><li><p><code>Q1</code> orthogonal <code>n</code>x<code>n</code> orthogonal matrix</p></li><li><p><code>L11</code> <code>t</code>x<code>t</code> lower triangular matrix</p></li><li><p><code>P1</code> <code>t</code>x<code>t</code> permutation matrix</p></li></ul></li><li><p><code>F_L11</code> : <code>QRPivoted</code> object containing infos about  QR decomposition of matrix <code>L11</code> such that  </p><ul><li><code>L11 * P2 = Q2 * [R11;0]</code></li></ul></li><li><p><code>rankA</code> : pseudo-rank of matrix <code>A</code></p></li><li><p><code>τ</code> : small positive value to compute the pseudo-rank of matrices</p></li></ul><p><strong>On return</strong></p><ul><li><p><code>p_gn</code> : vector of size <code>n</code>, contains the computed search direction </p></li><li><p><code>F_J2</code> : QR decomposition of Matrix <code>J2</code> defined in <a href="#Enlsip.sub_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, LinearAlgebra.Factorization, Int64, Int64, Int64, Int64, Int64, Int64}"><code>sub_search_direction</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L418-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.init_working_set-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Enlsip.Iteration, Int64, Int64}" href="#Enlsip.init_working_set-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Enlsip.Iteration, Int64, Int64}"><code>Enlsip.init_working_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_working_set(cx,K,step,q,l)</code></pre><p>Equivalent Fortran77 routine : INIALC</p><p>Compute the first working set by cheking which inequality constraints are strictly positive.</p><p>Then, initialize the penalty constants.</p><p><strong>Parameters</strong></p><ul><li><p><code>cx</code> : vector of size <code>l</code>, contains contraints evaluations</p></li><li><p><code>K</code> : array of vectors, contains infos about penalty constants computed throughout the algorithm</p></li><li><p><code>step</code> : object of type <a href="#Enlsip.Iteration"><code>Iteration</code></a>, containts infos about the current iteration, i.e. the first one when this function is called</p></li><li><p><code>q</code> : number of equality constraints</p></li><li><p><code>l</code> : total number of constraints</p></li></ul><p><strong>On return</strong></p><ul><li><code>first_working_set</code> : <a href="#Enlsip.WorkingSet"><code>WorkingSet</code></a> object, contains infos about the first working set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L1042-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.new_point!-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Int64, Int64, Int64}" href="#Enlsip.new_point!-Tuple{Vector{Float64}, Enlsip.ResidualsEval, Vector{Float64}, Enlsip.ConstraintsEval, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Int64, Int64, Int64}"><code>Enlsip.new_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_point!(x,r,rx,c,cx,J,A,n,m,l)</code></pre><p>Equivalent Fortran77 routine : NEWPNT</p><p>Compute in place the jacobians <code>J</code> and <code>A</code> corresponding to the residuals <code>rx</code> and the constraints <code>cx</code> evaluations respectively at current point x.</p><ul><li><p><code>n</code> is the number of parameters (size of <code>x</code>)</p></li><li><p><code>m</code> is the number of residuals (size of <code>rx</code>)</p></li><li><p><code>l</code>is the number of constraints (size of <code>cx</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L272-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.psi-Tuple{Vector{Float64}, Float64, Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Vector{Float64}, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#Enlsip.psi-Tuple{Vector{Float64}, Float64, Vector{Float64}, Enlsip.ResidualsEval, Enlsip.ConstraintsEval, Vector{Float64}, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>Enlsip.psi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">psi(x,α,p,r,c,w,m,l,t,active,inactive)</code></pre><p>Compute and return the evaluation of the merit function at <span>$(x+\alpha p,w)$</span> with current working set <span>$\mathcal{W}$</span> and the set of inactive constraints <span>$\mathcal{I}$</span></p><p><span>$\psi(x,w) = \dfrac{1}{2}\|r(x)\|^2 +  \dfrac{1}{2}\sum_{i \in \mathcal{W}} w_ic_i(x)^2 + \dfrac{1}{2} \sum_{j \in \mathcal{I}} w_j\min(0,c_j(x))^2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L1496-L1502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.search_direction_analys" href="#Enlsip.search_direction_analys"><code>Enlsip.search_direction_analys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_direction_analys</code></pre><p>Equivalent Fortran77 routine : ANALYS</p><p>Check if the latest step was sufficientlt good and eventually recompute the search direction by using either subspace minimization or the method of Newton</p><p><strong>On return</strong></p><ul><li><code>error_code</code> : integer indicating if there was an error if computations. In current version, errors can come from the method of Newton</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L1405-L1416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.sub_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, LinearAlgebra.Factorization, Int64, Int64, Int64, Int64, Int64, Int64}" href="#Enlsip.sub_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, LinearAlgebra.Factorization, Int64, Int64, Int64, Int64, Int64, Int64}"><code>Enlsip.sub_search_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_search_direction(J1,rx,cx,Q1,L11,P1,F_L11,F_J2,n,t,rankA,dimA,dimJ2,code)</code></pre><p>Equivalent Fortran77 routine : SUBDIR</p><p>Compute a search direction <code>p</code> by solving two triangular systems of equations.</p><p>First, for <code>p1</code>, either <code>L11*p1 = -P1&#39; * cx</code> or <code>R11*p1 = -Q2&#39; * P1&#39; * cx</code> is solved.</p><p>Then for <code>p2</code>, <code>R22*p2 = -Q3^T * [J1*p1 + rx]</code> is solved.</p><p><code>[J1;J2] = J * Q1 * P2</code> where <code>J</code> is the jacobian matrix of residuals.</p><p>Finally, the search direction is computed by forming : <code>p = Q1 * [p1 ; P3*p2]</code></p><p><strong>Parameters</strong></p><ul><li><p><code>rx</code> : residuals vector of size <code>m</code></p></li><li><p><code>cx</code> : active constraints vector of size <code>t</code></p></li><li><p><code>Q1</code>, <code>L11</code>, <code>P1</code> :  components of the LQ decomposition of active constraints jacobian matrix <code>A*P1 = Q1 * [L11 ; 0]</code></p><ul><li><p><code>Q1</code> orthogonal <code>n</code>x<code>n</code> orthogonal matrix</p></li><li><p><code>L11</code> <code>t</code>x<code>t</code> lower triangular matrix</p></li><li><p><code>P1</code> <code>t</code>x<code>t</code> permutation matrix</p></li></ul></li><li><p><code>F_L11</code> : <code>QRPivoted</code> object containing infos about  QR decomposition of matrix <code>L11</code> such that  </p><ul><li><code>L11 * P2 = Q2 * [R11;0]</code></li></ul></li><li><p><code>F_J2</code> : <code>QRPivoted</code> object containing infos about  QR decomposition of matrix <code>J2</code>, last <code>m-rankA</code> columns of <code>J*Q1</code></p><ul><li><code>J2 * P3 = Q3 * [R22;0]</code></li></ul></li><li><p><code>J1</code> first <code>rankA</code> columns of matrix <code>J*Q1</code></p></li><li><p><code>n</code> is the number of parameters</p></li><li><p><code>m</code> is the number of residuals (size of <code>rx</code>)</p></li><li><p><code>t</code> is the number of constraint in current working set</p></li><li><p><code>rankA</code> : pseudo-rank of matrix <code>A</code></p></li><li><p><code>dimA</code> : number of columns of matrix <code>R11</code> that should be used when <code>R11*p1 = -Q2&#39; * P1&#39; * cx</code> is solved</p></li><li><p><code>dimJ2</code> : number of columns of matrix <code>R22</code> that should be used when <code>R22*p2 = -Q3^T * [J1*p1 + rx]</code> is solved</p></li><li><p><code>code</code> : interger indicating which system to solve to compute <code>p1</code></p></li></ul><p><strong>On return</strong></p><ul><li><p><code>p</code> : vector of size <code>n</code>, contains the computed search direction </p></li><li><p><code>b</code> : vector of size <code>t</code>, contains the right handside of the system solved to compute <code>p1</code></p></li><li><p><code>d</code> : vector of size <code>m</code>, contains the right handside of the system solved to compute <code>p2</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L313-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enlsip.update_working_set-Tuple{Enlsip.WorkingSet, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.Iteration}" href="#Enlsip.update_working_set-Tuple{Enlsip.WorkingSet, Vector{Float64}, Matrix{Float64}, Enlsip.Constraint, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Enlsip.Iteration}"><code>Enlsip.update_working_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equivalent Fortran77 routine : WRKSET</p><p>First, an estimate the lagrange multipliers is computed. </p><p>If there are negative values among the multipliers computed, the constraint associated to the most negative multiplier is deleted from the working set.</p><p>Then, compute the search direction using Gauss-Newton method.</p><p><strong>Parameters</strong></p><ul><li><p><code>W</code> : represents the current working set (see <a href="#Enlsip.WorkingSet"><code>WorkingSet</code></a> for more details). Fields <code>t</code>, <code>active</code> and <code>inactive</code> may be modified when deleting a constraint</p></li><li><p><code>rx</code> : vector of size <code>m</code> containing residuals evaluations</p></li><li><p><code>A</code> : <code>l</code>x<code>n</code> jacobian matrix of constraints</p></li><li><p><code>J</code> = <code>m</code>x<code>n</code> jacobian matrixe of residuals</p></li><li><p><code>C</code> : represents constraints in current working set (see <a href="#Enlsip.Constraint"><code>Constraint</code></a> for more details)</p></li><li><p><code>∇fx</code> : vector of size <code>n</code>, gradient vector of the objective function</p></li><li><p><code>p_gn</code> : buffer vector of size <code>n</code>, represents the search direction</p></li><li><p><code>iter_k</code> : Contains infos about the current iteration (see <a href="#Enlsip.Iteration"><code>Iteration</code></a>)</p></li></ul><p><strong>On return</strong></p><ul><li><p><code>P1</code>, <code>L11</code>, <code>Q1</code>, <code>F_L11</code> and <code>F_J2</code> : QR decompositions used to solve linear systems when computing the search direction in <a href="#Enlsip.sub_search_direction-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, LinearAlgebra.Factorization, LinearAlgebra.Factorization, Int64, Int64, Int64, Int64, Int64, Int64}"><code>sub_search_direction</code></a></p></li><li><p>The fields of <code>iter_k</code> related to the computation of the search direction are modified in place </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pierre-borie/ENLSIP-Julia/blob/0c0a93712641339a49f805c0bff1b7a9bb05a23d/src/enlsip_functions.jl#L899-L931">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Wednesday 8 June 2022 11:51">Wednesday 8 June 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
